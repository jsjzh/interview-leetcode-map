/**
 * 算术运算符
 *
 * 加法运算符：x + y
 * 减法运算符： x - y
 * 乘法运算符： x * y
 * 除法运算符：x / y
 *
 * 指数运算符：x ** y
 * 余数运算符：x % y
 *
 * 自增运算符：++x 或者 x++
 * 自减运算符：--x 或者 x--
 *
 * 数值运算符： +x
 * 负数值运算符：-x
 */

/**
 * 加法计算符
 *
 * 是执行相加还是执行连接，是在运行时决定的，也就是说，运算子的不同导致了不同的语法行为，这种现象称为 "重载"（overload）
 * true + true // 2
 * 1 + true // 2
 * "a" + "bc" // "abc"
 * "a" + 1 // "a1"
 * "a" + true // "atrue"
 * "3" + 4 + 5 // "345"
 * 3 + 4 + "5" // "75"
 *
 * 除了加法运算符，其他算术运算符（减乘除）都不会发生重载，他们的规则是所有运算子一律转为数值再进行数学计算
 *
 * 对象的相加
 *
 * 如果运算子是对象，必须先转成原始类型的值然后再进行相加
 * var obj = { p: 1 }
 * obj + 2 // "[object Object]2"
 *
 * 对象转成原始类型的值规则如下，一般来说，对象的 valueOf() 总是返回对象自身，这时再自动调用对象的 toString() 将其转为字符串
 * var obj = { P: 1 }
 * obj.valueOf().toString()
 *
 * var obj = { valueOf: function() { return 1 } }
 * obj + 1 // 2
 * 上面的例子，定义 obj 对象的 valueOf() 返回 1，并且由于 valueOf() 直接返回一个原始类型的值，所以不再调用 toString()
 *
 * var obj = { toString: function() { return "hello" } }
 * obj + 2 // "hello2"
 *
 * 这里有一个特例，如果运算子是一个 Date 对象的实例，那么会优先执行 toString()
 * var obj = new Date()
 * obj.valueOf = function() { return 1 }
 * obj.toString = function() { return "hello" }
 * obj + 3 // "hello3"
 */

/**
 * 余数运算符
 *
 * 返回前一个运算子被后一个运算子除所得的余数，值得注意的是，运算结果的正负号由第一个运算子的正负号决定，所以为了得到负数的正确余数值，可以先用绝对值函数
 * function() { return Math.abs(n % 2) === 1 }
 */

/**
 * 自增和自减运算符
 *
 * 该运算符运算之后，变量的值会发生变化，这种效应叫做运算的副作用（side effect），++ 和 -- 是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值
 *
 * 值得注意的是，如果运算符放在变量之后，会先返回变量操作前的值再进行自增/自减操作；放在变量之后，会先进行自增/自减操作再返回变量操作后的值
 * var x = 1
 * var y = 1
 * x++ // 1
 * ++y // 2
 */

/**
 * 数值运算符
 *
 * 可以将任何值转为数值，使用加号，他和加法运算符的区别是他们所需的运算子的个数
 *
 * +true // 1
 * +[] // 0
 * +{} // NaN
 *
 * 负数值运算符
 *
 * 同样具有将值转为数值的功能，只不过得到的值正负相反
 */

/**
 * 指数运算符
 *
 * 前一个运算子是底数，后一个运算子是指数
 *
 * 2 ** 4 // 16
 *
 * 值得注意的是，指数运算符是右结合而不是左结合，即多个指数运算符连用时，先进行最右边的计算
 * 2 ** 3 ** 2 // 512 === 2 ** 9
 */

/**
 * 赋值运算符
 *
 * var x = 1
 * var x = y
 *
 * 复合赋值运算符
 *
 * 都是先进行指定运算，然后将值返回给左边的变量
 *
 * x += y === x = x + y
 * x -= y === x = x - y
 * x *= y === x = x * y
 * x /= y === x = x / y
 * x %= y === x = x % y
 * x **= y === x = x ** y
 *
 * x >>= y === x = x >> y
 * x <<= y === x = x << y
 * x >>>= y === x = x >>> y
 * x &= y === x = x & y
 * x |= y === x = x | y
 * x ^= y === x = x ^ y
 *
 *
 */
